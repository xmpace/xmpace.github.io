---
layout: post
title: "登录Token如何设计"
excerpt: "一种靠谱的登录Token设计"
background: /img/bg-post.jpg
---

客户端向服务器发送请求，服务器如何知道该请求是哪个用户发起的呢？为了标示请求的所属用户，客户端发送请求时必须带上用户的账号信息，像这样 /api/get_user_info?username=badboy123&password=goodgirl321，但这么一来，每个请求都得带上账号密码，这不安全，密码容易被泄露，于是诞生了以 token 为基础的认证方案。

客户端向服务器发送账号密码请求登录，服务器收到账号密码，校验后生成一个加密的 token 返回给客户端，后续客户端的所有请求都带上这个 token，服务器通过解密就能拿到客户端的登录账号信息了。现在密码被换成了 token，不用担心被泄露的问题了，但是 token 也会被泄露啊？是的，token 现在面临跟密码同样的问题，但 token 其实只相当于一个临时密码，用户退出登录后，这个 token 就失效了，所以token 被泄露的危害相较于密码被泄露的危害要小。

这篇文章介绍的就是一种 token 的设计。

上面介绍了 token 诞生的初衷，因此我们也知道了 token 需要满足的条件：
1. 服务端能通过 token 拿到用户账号信息（废话）
2. token 不能被伪造

我们看第 2 条就行了，防伪造，那简单啊，搞个随机数不就完了么。客户端发来账号和密码，服务端一校验，生成一个随机字符串，用随机字符串做 key，账号信息做 value，往 redis 一存就完了？这么干其实也可以，但是，用一个较长的字符串做 key 来查询，性能上不及用整型做查询。有没有方案能用整型做 key 呢？

账号一般都有账号 id，不妨用账号 id 来做 key，我们可以把账号 id 放进 token 里。账号 id 必须能通过直接解析 token 得到，这样一来，随机数防伪的方案就得抛弃了，我们得另寻防伪的方法。

说到防伪，在计算机领域首先想到的就是签名。比如我有一段 data，我在服务器上存了个密钥 "qwert"，我把密钥 "qwert" 拼在 data 后面做一个 SHA1 摘要算法，得到一个签名 sig，然后把 data 和 sig 拼接起来发放给客户端。客户端每次请求将 data 和 sig 带上，服务端收到后，如同之前的签名操作一样，将密钥 "qwert" 拼在 data 后面做SHA1 摘要得到一个签名 sig1，比较这个 sig1 和 客户端带来的 sig 是否相等就知道这个 data 是不是被伪造的了。

因此，我们可以先将账号 id 与密钥拼成一串，通过 SHA1 算法为这一串生成签名 sig，然后将 账号id 与 sig 拼接成最终的 token。

每次登录生成的 token 都应该不同，否则，token 一旦被泄露，相当于账号也被泄露了。为了生成不同的 token， 密钥就只能是随机的了。每次登录，我们就为该账号生成一串随机数作为密钥，并将其保存起来。

