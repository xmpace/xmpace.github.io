
## “乱序”其实并非乱序

指定执行是有步骤的，比如一条指令一般执行步骤如下：
1. 读取指令
2. 准备操作数
3. 在对应的工作单元执行指令（比如在加法器中做加法）
4. 将结果写到寄存器

如果让指令一条一条执行，会有什么问题呢？

效率太低！比如我前一条指令已经在第 3 步了，那么前两步的资源其实就已经让出来了，但这时候由于指令还没有执行完成，所以后面的指令无法进入，这就造成了资源的浪费。

因此，为了提高效率，我们把指令的执行过程划分成一段段的流水线，当前一条指令进入下一步流水线时，后面的指令就可以跟着进入流水线提前开始执行了。

这样能提高效率，但还不够！指令仍然是按顺序执行的，但其实没必要！

比如，我有两条指令

```
mov r1, mem1
mov r2, mem2
```

这两条指令其实谁先完成谁后完成，在单核 CPU 上，完全无所谓。反正最后的逻辑都是正确的。那如果 mem2 已经在 cache 中了，而 mem1 不在 cache 中，我也得先完成第一条指令，再完成第二条指令吗？

显然有更高效的做法。当第一条指令在等 mem1 时，第二条指令也可以同时执行，不必关心第一条指令是不是已经完成了。假设 CPU 有从 cache 及内存取数的工作单元，我只要把这种单元多做一个就行了。

现代 CPU 正是这样设计的。CPU 的指令执行单元（如加法器）往往会设计多个，以提高性能。

所以现代 CPU 的指令执行过程往往是这样的：

1. CPU 按顺序读取指令
2. 将指令分发到指令队列中（这个队列一般叫指令缓冲区或 (reservation stations)[https://en.wikipedia.org/wiki/Reservation_station]）
3. 队列中的指令，只要任何指令的操作数被准备好（有可能是前面指令的执行结果），并且当前有可用的执行单元（如加法器），则指令被发送到执行单元执行
4. 执行结果入队列
5. 如果执行结果有依赖关系，也需要按依赖关系写回结果。（比如前后两条指令执行后结果都写回 EAX 寄存器，那么尽管后面一条指令先出结果，也要等前面那条指令写完结果再写自己的结果）

由此可见，所谓乱序(Out-of-order)其实有点“名不副实”。“乱序”这个词说得好像是专门为了打乱顺序而去做的设计，其实乱序根本就不是初衷，它只是一个附属品。

真正的初衷，是让具备执行条件的指令，可以借助冗余设计的执行单元而优先执行，以提升指令执行的吞吐量。

所以“乱序”一词并不贴切，更贴切的可能是指令的“并行执行”(parallel execution)，“乱序”只是指令“并行执行”的一种表象而已。

*PS: 本文后面内容仍然会用“乱序”一词，以保持跟大家一致。*

## 指令的乱序执行会影响内存排序(memory ordering)吗？

指令的乱序执行我们已经知道了，我们接着再了解几个术语。

首先，什么是内存排序？

内存排序指的是处理器通过系统总线读写内存的顺序。

为什么会有内存排序出现？原因就是上面说的乱序执行，还是以上面的例子来说明：

```
1. mov r1, mem1
2. mov r2, mem2
```

主要程序得到的结果是正确的，这两条指令谁先谁后并不重要，对结果无影响。

如果指令 1 先执行，则程序是先读 mem1，再读 mem2，这就是一种内存顺序。顺便说一句，这种顺序也叫 **程序顺序(program ordering)**。

如果指令 2 先执行，则程序是先读 mem2，再读 mem1，那么这又是另一种内存顺序。

## 参考资料
1. https://en.wikipedia.org/wiki/Out-of-order_execution
2. Intel SDM vol 3